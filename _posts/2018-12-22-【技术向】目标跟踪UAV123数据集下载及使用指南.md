---
layout:     post
title:      ã€æŠ€æœ¯å‘ã€‘ç›®æ ‡è·Ÿè¸ªUAV123æ•°æ®é›†ä¸‹è½½åŠä½¿ç”¨æŒ‡å—
date:       2018-12-08
author:     tominute
header-img: img/post-bg-map.jpg
catalog: true
tags:
    - Tracking
    - Matlab
---
ä»Šå¤©æ¨ä¸€ç¯‡æ™®åŠæ€§æ–‡ç« ï¼Œå¤§å®¶çŸ¥é“ç›®æ ‡è·Ÿè¸ªå¸¸ç”¨æ•°æ®é›†æœ‰OTBå’ŒVOTç³»åˆ—ï¼Œç°åœ¨è¿˜æœ‰æ›´å¤§çš„æ•°æ®é›†LASOTå’ŒTrackingNetå‡ºç°ï¼Œæ­¤å¤–æœ‰ä¸€ä¸ªå«åšUAV123çš„æ•°æ®é›†ï¼Œæ˜¯ä¸€ä¸ªä¸“é—¨åœºæ™¯çš„æ•°æ®é›†ï¼Œéƒ½æ˜¯ç”¨æ— äººæœºæ‹æ‘„ï¼Œç‰¹ç‚¹æ˜¯èƒŒæ™¯å¹²å‡€ï¼Œè§†è§’å˜åŒ–è¾ƒå¤šï¼ŒåŒ…å«123ä¸ªè§†é¢‘ï¼Œæ€»å¤§å°åœ¨13.5Gå·¦å³ã€‚ä¸€äº›çŸ¥åçš„è·Ÿè¸ªç®—æ³•ä¼šä½¿ç”¨UAVè¿›è¡Œè¯„æµ‹ï¼Œæ¯”å¦‚ECOç­‰ã€‚å¯ä»¥æŸ¥çœ‹UAVè®ºæ–‡çœ‹çœ‹è¯¦ç»†ä»‹ç»ğŸ‘‰[UAV123è®ºæ–‡ECCV16](https://ivul.kaust.edu.sa/Documents/Publications/2016/A%20Benchmark%20and%20Simulator%20for%20UAV%20Tracking.pdf)ã€‚æœ¬æ–‡å°†æä¾›è¯¥æ•°æ®é›†çš„ä¸‹è½½åŠä½¿ç”¨æ–¹æ³•ï¼Œè‡ªè·‘è‡ªè¯„ï¼Œä¸ç”¨å…¶ä»–å·¥å…·ã€‚æœ‰é—®é¢˜æ¬¢è¿è®¨è®º~
![1](/img/20181222/1.JPG)
# 1. ä¸‹è½½
ä¸‹è½½æ¸ é“1ï¼šğŸ‘‰[UAV123æ•°æ®é›†ä¸»é¡µ](https://ivul.kaust.edu.sa/Pages/Dataset-UAV123.aspx)
ä¸‹è½½æ¸ é“2ï¼šğŸ‘‰[ç™¾åº¦ç½‘ç›˜](https://pan.baidu.com/s/1hQCIjEx5VCZ455IL-Z6y3Q)ï¼Œæå–ç ï¼š7lwk 

å¤åˆ¶è¿™æ®µå†…å®¹åæ‰“å¼€ç™¾åº¦ç½‘ç›˜æ‰‹æœºAppï¼Œæ“ä½œæ›´æ–¹ä¾¿å“¦)ï¼Œå…¶ä¸­åŒ…å«5ä¸ªå‹ç¼©åŒ…ï¼Œä¸€èµ·è§£å‹å°±è¡Œã€‚
# 2.ä½¿ç”¨æŒ‡å—
### 2.1 ä¸»è¦æ–‡ä»¶
annoæ–‡ä»¶å¤¹åŒ…å«UAV20Lå’ŒUAV123çš„groundtruthæ ‡æ³¨ï¼Œæ ¼å¼ä¸ºå·¦ä¸Šè§’åæ ‡å’Œé•¿å®½å››ä¸ªå€¼ä¸€è¡Œ/å¸§ï¼Œæˆ‘ä»¬ä¸€èˆ¬ä½¿ç”¨çš„æ˜¯UAV123ï¼Œå…¶ä¸­å­æ–‡ä»¶å¤¹attåŒ…å«æ¯ä¸ªè§†é¢‘çš„å±æ€§æ ‡æ³¨ï¼Œå…·ä½“å¯ä»¥æŸ¥çœ‹ä¸»ç›®å½•ä¸‹çš„DatasetAnnotation.pdfæ–‡ä»¶ï¼›
ç¬¬äºŒä¸ªæ˜¯data_seqæ–‡ä»¶å¤¹ï¼ŒåŒ…å«æ•°æ®é›†çš„æ‰€æœ‰å›¾ç‰‡æ–‡ä»¶å‘½åæ–¹å¼ä¸º06i.jpgï¼›
è¿˜æœ‰ä¸€ä¸ªconfigSeqs.mæ–‡ä»¶ï¼Œæ˜¯æ¨¡ä»¿OTBå·¥å…·çš„è§†é¢‘ä¿¡æ¯æ–‡ä»¶ï¼Œåé¢æˆ‘ä»¬å°†ä½¿ç”¨å®ƒè¿›è¡Œç®€å•çš„è·‘åº“ã€‚

### 2.2 é¢„å¤„ç†
å†™äº†ä¸€ä¸ªutils_UAV.mæ–‡ä»¶ï¼Œé‡Œé¢æœ‰ä¸€äº›å®ç”¨çš„ç¨‹åºï¼Œå¯ä»¥åœ¨ç½‘ç›˜ä¸­ä¸‹è½½ã€‚
æˆ‘ä»¬çš„ç›®æ ‡æ˜¯åšæˆOTBæ•°æ®é›†é‚£æ ·çš„æ ¼å¼ä¾¿äºè·‘åº“ï¼Œæ¯ä¸ªè§†é¢‘è¿˜ç¼ºä¸€ä¸ªframeæ–‡ä»¶ï¼Œå³æŒ‡å®šèµ·å§‹å¸§å’Œç»ˆæ­¢å¸§çš„æ–‡ä»¶ï¼Œå¯ä»¥é€šè¿‡configSeqs.mç”Ÿæˆï¼Œé¦–å…ˆåœ¨ä¸»ç›®å½•æ–°å»ºframeæ–‡ä»¶å¤¹ï¼Œç„¶åè¿è¡Œä¸‹é¢ç¨‹åºã€‚

```
%% achieve frame files like OTB
base_path = 'ä¸»ç›®å½•/anno/UAV123/';
seqs = configSeqs;
for i = 1:numel(seqs)
    frame_name = [seqs{i}.name '_frames.txt'];
    file_name = ['./frame/' frame_name];
    fid  = fopen(file_name, 'wt');
    fprintf(fid, '%d,%d\n',seqs{i}.startFrame, seqs{i}.endFrame);
    fclose(fid);
end
```

ä¸‹é¢æˆ‘ä»¬æ‰“å°ä¸€ä¸‹æ¯ä¸ªè§†é¢‘çš„åç§°ï¼Œä¾¿äºåé¢è·‘åº“ä½¿ç”¨

```
%% print seq names
fid  = fopen('seq_names.txt','wt');
for i = 1:numel(seqs)
    fprintf(fid, '''%s'',',seqs{i}.name);
end
fclose(fid);
```
å½“ç„¶ä½ ä¹Ÿå¯ä»¥æ£€æŸ¥ä¸€ä¸‹æ˜¯ä¸æ˜¯éƒ½æ˜¯å½©è‰²è§†é¢‘

```
base_path = 'ä¸»ç›®å½•/data_seq/UAV123/';
for i = 1:numel(seqs)
    img = imread([base_path seqs{i}.name '/' num2str(seqs{i}.startFrame, '%06i.jpg')]);
    if size(img,3) == 1
        disp([seqs{i}.name]);
    end
end
```

### 2.3 è·‘åº“ä¸è¯„æµ‹
####2.3.1 è·‘åº“
æˆ‘ä»¬ä»¥ECOä¸ºä¾‹ï¼Œè·‘ECO-HCè·Ÿè¸ªç®—æ³•ï¼Œä½ ä¹Ÿå¯ä»¥è·‘SRDCFç®—æ³•ï¼Œè®¾ç½®éƒ½ä¸€æ ·ã€‚ä½ å¯ä»¥ä¸‹è½½æˆ‘ç”¨æ¥è·‘åº“çš„ECOçš„ç¤ºä¾‹ğŸ‘‰[ä»£ç ](https://pan.baidu.com/s/1P071Hwg6EyBMzgK7XLkHcA)
é¦–å…ˆåœ¨ECOä»£ç æ–‡ä»¶ä¸­ï¼Œutilsæ–‡ä»¶å¤¹ä¸­å¢åŠ ä¸€ä¸ªç±»ä¼¼load_video_info.mçš„æ–‡ä»¶ç”¨äºæå–UAVæ•°æ®é›†çš„ä¿¡æ¯ï¼Œèµ·åä¸ºload_video_info_UAV.mï¼Œå†…å®¹å¦‚ä¸‹

```
function [seq, ground_truth] = load_video_info_UAV(gt_path, img_path, frame_path, testSet, seqs)
ground_truth = load([gt_path testSet '.txt']);
seq.format = 'otb';
seq.len = size(ground_truth, 1);
seq.init_rect = ground_truth(1,:);
f = fopen([frame_path testSet '_frames.txt']);
frames = textscan(f, '%f,%f');
fclose(f);
img_path = seqs.path;
img_files = num2str((frames{1}:frames{2})', [img_path '%06i.jpg']);
seq.s_frames = cellstr(img_files);
end
```

ç„¶åECOä»£ç ä¸»ç›®å½•æ–°å»ºä¸€ä¸ªè·‘åº“ä¸»å‡½æ•°demo_UAV.mï¼Œå¹¶æŠŠUAV123æ•°æ®é›†ä¸­çš„configSeqs.mæ–‡ä»¶å¤åˆ¶è¿›æ¥ã€‚demo_UAV.må†…å®¹å¦‚ä¸‹
```
% Add paths
setup_paths();
seqs = configSeqs;
% Load video information
gt_path = 'UAV123ä¸»ç›®å½•/anno/UAV123/';
img_path = 'UAV123ä¸»ç›®å½•/data_seq/UAV123/';
frame_path = 'UAV123ä¸»ç›®å½•/frame/';
UAV123 = {'bike1','bike2','bike3','bird1_1','bird1_2','bird1_3','boat1','boat2','boat3','boat4','boat5','boat6','boat7','boat8','boat9','building1','building2','building3','building4',...
    'building5','car1_1','car1_2','car1_3','car2','car3','car4','car5','car6_1','car6_2','car6_3','car6_4','car6_5','car7','car8_1','car8_2','car9','car10','car11','car12','car13',...
    'car14','car15','car16_1','car16_2','car17','car18','group1_1','group1_2','group1_3','group1_4','group2_1','group2_2','group2_3','group3_1','group3_2','group3_3','group3_4',...
    'person1','person2_1','person2_2','person3','person4_1','person4_2','person5_1','person5_2','person6','person7_1','person7_2','person8_1','person8_2','person9','person10',...
    'person11','person12_1','person12_2','person13','person14_1','person14_2','person14_3','person15','person16','person17_1','person17_2','person18','person19_1','person19_2',...
    'person19_3','person20','person21','person22','person23','truck1','truck2','truck3','truck4_1','truck4_2','uav1_1','uav1_2','uav1_3','uav2','uav3','uav4','uav5','uav6','uav7',...
    'uav8','wakeboard1','wakeboard2','wakeboard3','wakeboard4','wakeboard5','wakeboard6','wakeboard7','wakeboard8','wakeboard9','wakeboard10','car1_s','car2_s','car3_s','car4_s',...
    'person1_s','person2_s','person3_s'};
testSet = UAV123;
if ~exist('res', 'dir')
    mkdir('res');
end
%% run UAV
for i = 1:length(testSet)
    [seq, ground_truth] = load_video_info_UAV(gt_path, img_path, frame_path, testSet{i}, seqs{i});    
    results = testing_ECO_HC(seq);
    results.res = [results.res(:,[2,1]) + (results.res(:,[4,3]) - 1) / 2 , results.res(:,[4,3])];
    res = results.res;
    save(['./res/' testSet{i} '_UAV.mat'], 'res');
end
```

#### 2.3.2 è¯„æµ‹
æ³¨æ„æˆ‘ä»¬æŠŠç»“æœçš„å½¢å¼ä¿å­˜æˆä¸­å¿ƒåæ ‡å’Œé•¿å®½çš„å½¢å¼ï¼Œä»¥ä¾¿äºä¸‹é¢çš„è¯„æµ‹ã€‚ä¸»è¦æŒ‡æ ‡æ˜¯AUCå’Œç²¾åº¦ï¼Œå’ŒOTBæŠ¥å‘Šçš„ä¸€æ ·ï¼Œåªä¸è¿‡æ²¡æœ‰æ›²çº¿å›¾ï¼Œæƒ³è¦å¯ä»¥è‡ªå·±åŠ ã€‚
è¯„æµ‹æ—¶æŠŠrun UAVä¸‹é¢éƒ½æ³¨é‡Šæ‰ï¼Œå¢åŠ è¯„æµ‹ä»£ç å¦‚ä¸‹
```
average_center_location_error_sum=0;
distance_precision_sum=0;
PASCAL_precision_sum=0;
Overlap_sum=0;
fps_sum=0;
fid = fopen('results_UAV.txt', 'wt');
for i = 1:length(testSet)
    [seq, ground_truth] = load_video_info_UAV(gt_path, img_path, frame_path, testSet{i}, seqs{i});
    ground_truth = [ground_truth(:,[2,1]) + (ground_truth(:,[4,3])-1)/2 , ground_truth(:,[4,3])];
    results.fps = 0;
    load(['./res/' testSet{i} '_UAV.mat'], 'res');
    ground_truth2 = [];
    positions2 = [];
    for j = 1:size(ground_truth,1)
        if isnan(ground_truth(j,1))
            continue;
        else
            ground_truth2 =  [ground_truth2;ground_truth(j,1:4)];
            positions2 = [positions2; res(j,1:4)];
        end
    end
    [distance_precision, PASCAL_precision, average_center_location_error, Overlap] = ...
        compute_performance_measures(positions2, ground_truth2, 20, 0.5);
    disp([num2str(Overlap) testSet{i}]);
    fprintf(fid, '%.5g %%, %s\n', 100*Overlap, testSet{i});
    average_center_location_error_sum=average_center_location_error_sum+average_center_location_error;
    distance_precision_sum=distance_precision_sum+distance_precision;
    PASCAL_precision_sum=PASCAL_precision_sum+PASCAL_precision;
    Overlap_sum=Overlap_sum+Overlap;
    fps_sum=fps_sum+results.fps;
end
average_center_location_error=average_center_location_error_sum/length(testSet);
distance_precision=distance_precision_sum/length(testSet);
PASCAL_precision=PASCAL_precision_sum/length(testSet);
Overlap=Overlap_sum/length(testSet);
fps=fps_sum/length(testSet);
fprintf('Center Location Error: %.3g pixels\nDistance Precision: %.3g %%\nOverlap Precision: %.5g %%\nOverlap: %.5g%%\nSpeed: %.5g fps\n', ...
    average_center_location_error, 100*distance_precision, 100*PASCAL_precision,100*Overlap, fps);
fprintf(fid, '%.5g %%, %s\n', 100*Overlap, 'All');
fclose(fid);
```

å…¶ä¸­compute_performance_measureså‡½æ•°å¦‚ä¸‹
```
function [distance_precision, PASCAL_precision, average_center_location_error,Overlap] = ...
    compute_performance_measures(positions, ground_truth, distance_precision_threshold, PASCAL_threshold)
% [distance_precision, PASCAL_precision, average_center_location_error] = ...
%    compute_performance_measures(positions, ground_truth, distance_precision_threshold, PASCAL_threshold)
%
% For the given tracker output positions and ground truth it computes the:
% * Distance Precision at the specified threshold (20 pixels as default if
% omitted)
% * PASCAL Precision at the specified threshold (0.5 as default if omitted)
% * Average Center Location error (CLE).
%
% The tracker positions and ground truth must be Nx4-matrices where N is
% the number of time steps in the tracking. Each row has to be on the form
% [c1, c2, s1, s2] where (c1, c2) is the center coordinate and s1 and s2 
% are the size in the first and second dimension respectively (the order of 
% x and y does not matter here).
if nargin < 3 || isempty(distance_precision_threshold)
    distance_precision_threshold = 20;
end
if nargin < 4 || isempty(PASCAL_threshold)
    PASCAL_threshold = 0.5;
end
if size(positions,1) ~= size(ground_truth,1),
    disp('Could not calculate precisions, because the number of ground')
    disp('truth frames does not match the number of tracked frames.')
    return
end
%calculate distances to ground truth over all frames
distances = sqrt((positions(:,1) - ground_truth(:,1)).^2 + ...
    (positions(:,2) - ground_truth(:,2)).^2);
distances(isnan(distances)) = [];
%calculate distance precision
distance_precision = nnz(distances < distance_precision_threshold) / numel(distances);
%calculate average center location error (CLE)
average_center_location_error = mean(distances);
%calculate the overlap in each dimension
overlap_height = min(positions(:,1) + positions(:,3)/2, ground_truth(:,1) + ground_truth(:,3)/2) ...
    - max(positions(:,1) - positions(:,3)/2, ground_truth(:,1) - ground_truth(:,3)/2);
overlap_width = min(positions(:,2) + positions(:,4)/2, ground_truth(:,2) + ground_truth(:,4)/2) ...
    - max(positions(:,2) - positions(:,4)/2, ground_truth(:,2) - ground_truth(:,4)/2);
% if no overlap, set to zero
overlap_height(overlap_height < 0) = 0;
overlap_width(overlap_width < 0) = 0;
% remove NaN values (should not exist any)
valid_ind = ~isnan(overlap_height) & ~isnan(overlap_width);
% calculate area
overlap_area = overlap_height(valid_ind) .* overlap_width(valid_ind);
tracked_area = positions(valid_ind,3) .* positions(valid_ind,4);
ground_truth_area = ground_truth(valid_ind,3) .* ground_truth(valid_ind,4);
% calculate PASCAL overlaps
overlaps = overlap_area ./ (tracked_area + ground_truth_area - overlap_area);
% calculate PASCAL precision
Overlap = mean(overlaps);
PASCAL_precision = nnz(overlaps >= PASCAL_threshold) / numel(overlaps);
end
```

#### 2.3.3 æ³¨æ„äº‹é¡¹
1. UAVçš„è§†é¢‘éƒ¨åˆ†æœ‰ç›®æ ‡å®Œå…¨ç¦»å¼€è§†é‡çš„æƒ…å†µï¼Œè¿™ç§æƒ…å†µçš„groundtruthæ ‡æ³¨ä¸ºNaN,NaN,NaN,NaNï¼Œæ‰€ä»¥åœ¨è¯„æµ‹æ—¶æˆ‘ä»¬å…ˆæŠŠè¿™éƒ¨åˆ†å¸§å‰”é™¤å†è¿›è¡Œè®¡ç®—ï¼›
2. è¿™ç§è‡ªè·‘è‡ªè¯„çš„æ–¹æ³•ä¸é™äºUAVåº“ï¼ŒOTBå’ŒVOTéƒ½é€‚ç”¨ã€‚